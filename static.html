<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>üó£Ô∏è Dialogue TTS Reader</title>

    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
      .controls,
      .dialogue-controls {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      .dialogue-line {
        margin-bottom: 10px;
        padding: 10px;
        border-bottom: 1px dashed #eee;
        /* cursor: pointer; */
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .dialogue-line:hover {
        background-color: #f0f0f0;
      }
      .speaker {
        font-weight: bold;
        margin-right: 10px;
        color: #0056b3;
      }
      .speaker.speaker-a {
        color: #0056b3;
      }
      .speaker.speaker-b {
        color: green;
      }
      .speaker.speaker-c {
        color: purple;
      }
      .speaker.speaker-d {
        color: rgb(183, 103, 0);
      }
      .current-speaking {
        background-color: #e6f7ff;
        border-left: 5px solid #007bff;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      input[type="range"] {
        width: 300px;
      }
      button {
        padding: 10px 15px;
        margin-right: 10px;
        cursor: pointer;
      }
      .line-button {
        padding: 5px 10px;
        margin-right: 10px;
        background-color: #e6f7ff;
        color: #0056b3;
        border: 1px solid #0056b3;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.9em;
      }
      .line-button:hover {
        background-color: #b3d9ff;
      }
      #log {
        margin-top: 20px;
        padding: 10px;
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        max-height: 150px;
        overflow-y: auto;
        font-size: 0.9em;
      }
      .loading-info {
        padding: 15px;
        background-color: #fff3cd;
        border: 1px solid #ffeeba;
        border-radius: 5px;
      }
      .kana-text {
        font-size: 0.8em;
        color: #555;
        display: block;
      }
    </style>
  </head>

  <body>
    <h1>üó£Ô∏è Dialogue TTS rateSlider</h1>

    <div class="controls">
      <div class="loading-info">
        ‚ÑπÔ∏è **Status:** Attempting to load dialogue from
        **`static-data.json`**...
      </div>
    </div>

    <div class="dialogue-controls">
      <h2>Reader Settings</h2>

      <label for="rateSlider"
        >Speech Rate: <span id="rateValue">1.0</span></label
      >

      <input
        type="range"
        id="rateSlider"
        min="0.5"
        max="2.0"
        value="1.0"
        step="0.1"
      />

      <p>
        <button id="readAllBtn" disabled>‚ñ∂Ô∏è Read All Dialogue</button>
        <button id="stopBtn" disabled>‚èπÔ∏è Stop Reading</button>
      </p>

      <p>Click any line below to read it individually.</p>
    </div>

    <h2>üìú Dialogue Content</h2>

    <div id="dialogueContainer">
      <p>Loading dialogue content...</p>
    </div>

    <div id="log"><strong>Message Log:</strong><br /></div>

    <script>
      const synth = window.speechSynthesis;
      const dialogueContainer = document.getElementById("dialogueContainer");
      const rateSlider = document.getElementById("rateSlider");
      const rateValueSpan = document.getElementById("rateValue");
      const readAllBtn = document.getElementById("readAllBtn");
      const stopBtn = document.getElementById("stopBtn");
      const logDiv = document.getElementById("log");

      const STATIC_DATA_FILE = "static-data.json";

      let dialogueData = null;
      let voices = [];
      let currentUtterance = null;
      let dialogueIndex = 0;
      let speakerVoiceMap = {};
      let isReadingAll = false; // --- Voice Initialization ---

      function populateVoices() {
        voices = synth.getVoices();
        logMessage(`Found ${voices.length} system voices.`);
        if (dialogueData) {
          initializeVoicesForDialogue();
        }
      }

      if (synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = populateVoices;
      } else {
        populateVoices();
      } // --- Utility Functions ---

      function logMessage(message, isError = false) {
        const time = new Date().toLocaleTimeString("en-US");
        const color = isError ? "red" : "green";
        logDiv.innerHTML =
          `<span style="color:${color};">[${time}] ${message}</span><br>` +
          logDiv.innerHTML;
        logDiv.scrollTop = 0;
      }

      function initializeVoicesForDialogue() {
        speakerVoiceMap = {};
        if (!dialogueData || voices.length === 0) return;

        const targetLang = dialogueData.language_code;
        const langVoices = voices.filter((v) => v.lang.startsWith(targetLang));

        if (langVoices.length === 0) {
          logMessage(
            `Warning: No voices found for language code ${targetLang}. Using default browser voice.`,
            true,
          );
          return;
        }

        const uniqueSpeakers = [
          ...new Set(dialogueData.dialogue.map((line) => line.speaker)),
        ];

        uniqueSpeakers.forEach((speaker, index) => {
          const voiceIndex = index % langVoices.length;
          const selectedVoice = langVoices[voiceIndex];
          speakerVoiceMap[speaker] = selectedVoice;
          logMessage(
            `Mapped speaker **${speaker}** to voice: **${selectedVoice.name}**`,
          );
        });
      }

      function getVoice(lang, speakerName) {
        if (speakerVoiceMap[speakerName]) {
          return speakerVoiceMap[speakerName];
        }

        return voices.find((v) => v.lang.startsWith(lang));
      } // --- Core TTS Function ---

      function speak(
        text,
        lang,
        speakerName,
        lineElement,
        isAllMode = false,
        callback = () => {},
      ) {
        // Stop current speech if not in continuous mode
        if (!isAllMode && synth.speaking) {
          synth.cancel();
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = parseFloat(rateSlider.value);

        const voiceMatch = getVoice(lang, speakerName);

        if (voiceMatch) {
          utterance.voice = voiceMatch;
          logMessage(
            `Using voice: ${voiceMatch.name} (${voiceMatch.lang}) for ${speakerName}`,
          );
        } else {
          utterance.lang = lang;
          logMessage(
            `No specific voice found. Using default voice for language: ${lang}`,
          );
        }

        currentUtterance = utterance; // Highlight the speaking line

        document
          .querySelectorAll(".current-speaking")
          .forEach((el) => el.classList.remove("current-speaking"));
        if (lineElement) {
          lineElement.classList.add("current-speaking");
          lineElement.scrollIntoView({ behavior: "smooth", block: "center" });
        }

        stopBtn.disabled = false;

        utterance.onend = () => {
          logMessage(`Speech ended: ${text.substring(0, 30)}...`); // Only proceed to the next line if in 'Read All' mode AND isReadingAll is still true

          if (
            !isAllMode ||
            dialogueIndex >= dialogueData.dialogue.length ||
            !isReadingAll
          ) {
            document
              .querySelectorAll(".current-speaking")
              .forEach((el) => el.classList.remove("current-speaking"));
            stopBtn.disabled = true;
            readAllBtn.disabled = !dialogueData || false;
            isReadingAll = false; // Ensure flag is reset after natural finish
          }
          currentUtterance = null;
          callback();
        };

        utterance.onerror = (event) => {
          logMessage(`TTS Error for ${speakerName}: ${event.error}`, true);
          currentUtterance = null;
          callback();
        };

        synth.speak(utterance);
      } // --- Single Line Reading ---

      function readNextLine() {
        // Check if reading was stopped externally or if we are at the end
        if (
          !isReadingAll ||
          !dialogueData ||
          dialogueIndex >= dialogueData.dialogue.length
        ) {
          if (isReadingAll) {
            logMessage("All dialogue lines finished.");
          } // Reset state regardless of how it ended
          isReadingAll = false;
          stopBtn.disabled = true;
          readAllBtn.disabled = !dialogueData || false;
          document
            .querySelectorAll(".current-speaking")
            .forEach((el) => el.classList.remove("current-speaking"));
          return;
        }

        const line = dialogueData.dialogue[dialogueIndex];
        const lineElement = document.querySelector(
          `.dialogue-line[data-index="${dialogueIndex}"]`,
        );

        speak(
          line.kana ?? line.text,
          dialogueData.language_code,
          line.speaker,
          lineElement,
          true,
          () => {
            // This callback runs after onend or onerror, but only if isReadingAll was true when speak started.
            dialogueIndex++;
            readNextLine();
          },
        );
      } // --- Stop Function ---

      function stopReading() {
        // Set flag to false BEFORE canceling speech
        isReadingAll = false;
        synth.cancel();
        document
          .querySelectorAll(".current-speaking")
          .forEach((el) => el.classList.remove("current-speaking"));
        stopBtn.disabled = true;
        readAllBtn.disabled = !dialogueData || false;
        logMessage("Reading stopped by user.");
      }

      function playThisLineOnly(index) {
        if (!dialogueData || index < 0 || index >= dialogueData.dialogue.length)
          return;

        // Stop any currently playing speech
        if (synth.speaking) {
          synth.cancel();
        }
        document
          .querySelectorAll(".current-speaking")
          .forEach((el) => el.classList.remove("current-speaking"));

        // Play only this line
        const line = dialogueData.dialogue[index];
        const lineElement = document.querySelector(
          `.dialogue-line[data-index="${index}"]`,
        );
        isReadingAll = false;
        logMessage(`Playing line ${index + 1}...`);
        speak(
          line.kana ?? line.text,
          dialogueData.language_code,
          line.speaker,
          lineElement,
          false,
        );
      }

      function playFromLine(startIndex) {
        if (
          !dialogueData ||
          startIndex < 0 ||
          startIndex >= dialogueData.dialogue.length
        )
          return;

        // Stop any currently playing speech
        stopReading();
        setTimeout(() => {
          dialogueIndex = startIndex;
          readAllBtn.disabled = true;
          isReadingAll = true;
          logMessage(`Starting playback from line ${startIndex}...`);
          readNextLine();
        }, 100);
      } // --- Rendering Dialogue ---

      function renderDialogue(data) {
        dialogueContainer.innerHTML = ""; // Clear existing content

        const langH3 = document.createElement("h3");
        langH3.textContent = `Language Code: ${data.language_code}`;
        dialogueContainer.appendChild(langH3);
        data.dialogue.forEach((line, index) => {
          const lineDiv = document.createElement("div");
          lineDiv.className = "dialogue-line";
          lineDiv.dataset.index = index;
          lineDiv.dataset.speaker = line.speaker;

          const speakerSpan = document.createElement("span");
          speakerSpan.className = "speaker";
          // Add speaker-specific class based on speaker-code attribute
          if (line["speaker-code"]) {
            speakerSpan.classList.add(line["speaker-code"]);
          }
          speakerSpan.textContent = line.speaker + ":";

          const textDiv = document.createElement("div");
          textDiv.className = "text-container";

          const textSpan = document.createElement("span");
          textSpan.textContent = line.text;
          textDiv.appendChild(textSpan);

          if (!!line.kana) {
            const kanaSpan = document.createElement("span");
            kanaSpan.className = "kana-text";
            kanaSpan.textContent = line.kana;
            textDiv.appendChild(kanaSpan);
          }

          const playThisBtn = document.createElement("button");
          playThisBtn.className = "line-button";
          playThisBtn.textContent = "‚ñ∂Ô∏è";
          playThisBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            playThisLineOnly(index);
          });

          const playFromLineBtn = document.createElement("button");
          playFromLineBtn.className = "line-button";
          playFromLineBtn.textContent = "‚ñ∂Ô∏è‚¨áÔ∏è";
          playFromLineBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            playFromLine(index);
          });
          const stopBtn = document.createElement("button");
          stopBtn.className = "line-button";
          stopBtn.textContent = "‚èπÔ∏è";
          stopBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            stopReading();
          });

          const btnContainer = document.createElement("div");
          btnContainer.className = "button-container";
          btnContainer.appendChild(playThisBtn);
          btnContainer.appendChild(playFromLineBtn);
          btnContainer.appendChild(stopBtn);

          lineDiv.appendChild(speakerSpan);
          lineDiv.appendChild(textDiv);
          lineDiv.appendChild(btnContainer);

          dialogueContainer.appendChild(lineDiv);
        });
        logMessage("Dialogue content displayed.");
      } // --- Static Data Loading ---

      async function loadStaticData() {
        // FIX: Append a unique timestamp (cache buster) to the file URL
        const cacheBuster = `?t=${new Date().getTime()}`;
        const fetchURL = STATIC_DATA_FILE + cacheBuster;

        try {
          const response = await fetch(fetchURL);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();

          if (!data.language_code || !Array.isArray(data.dialogue)) {
            throw new Error(
              'Invalid JSON format: Missing "language_code" or "dialogue" array.',
            );
          }

          dialogueData = data;
          renderDialogue(dialogueData);

          if (voices.length > 0) {
            initializeVoicesForDialogue();
          }

          readAllBtn.disabled = false;
          logMessage(`${STATIC_DATA_FILE} loaded successfully (Cache Busted).`);
        } catch (err) {
          dialogueContainer.innerHTML = `<p style="color: red;">Error loading static data from <strong>${STATIC_DATA_FILE}</strong>. Please ensure the file exists in the same directory and follows the required schema. (Error: ${err.message})</p>`;
          readAllBtn.disabled = true;
          logMessage(`Data Loading Error: ${err.message}`, true);
        }
      } // --- Event Listeners ---

      rateSlider.addEventListener("input", () => {
        rateValueSpan.textContent = rateSlider.value; // If currently speaking, update the rate immediately
        if (currentUtterance && !synth.paused) {
          currentUtterance.rate = parseFloat(rateSlider.value);
        }
      });

      readAllBtn.addEventListener("click", () => playFromLine(0));
      stopBtn.addEventListener("click", stopReading);

      document.addEventListener("DOMContentLoaded", () => {
        readAllBtn.disabled = true;
        stopBtn.disabled = true;
        loadStaticData();
      });
    </script>
  </body>
</html>
